<?xml version="1.0" encoding="UTF-8"?>
<chapter id="tutorial">
	<title>MobilityDB Tutorial</title>
	<para>To illustrate the capabilities of MobilityDB, we give an example use case that loads, explores, and query mobility data. The data used is based on the <ulink url="http://dna.fernuni-hagen.de/secondo/BerlinMOD/BerlinMOD.html">BerlinMOD</ulink> benchmark for moving object databases and is available as a <ulink url="https://docs.mobilitydb.com/data/berlinmod_data.zip">ZIP</ulink> file.</para>

	<sect1>
		<title>Installation</title>

		<para>For this tutorial we will use a Docker image containing MobilityDB and all its dependencies (including PostgreSQL and PostGIS). Alternatively, if you have already installed MobilityDB from the sources available in <ulink url ="https://github.com/MobilityDB/MobilityDB">Github</ulink>, you can skip the remaining of this section that pertains to running the tutorial in Docker.</para>

    <para>The Docker container has a default database called <varname>mobilitydb</varname> with the MobilityDB extension installed where <varname>user = pw = docker</varname>. This presupposes that you have installed Docker into your computer. In that case, you can run the following command.
			<programlisting xml:space="preserve">
docker pull mobilitydb/mobilitydb
docker volume create mobilitydb_data
docker run --name "mobilitydb" -d -p 25432:5432 -v mobilitydb_data:/var/lib/postgresql
mobilitydb/mobilitydb
</programlisting>
			In the above commands
			<itemizedlist>
				<listitem><para><varname>docker pull</varname> downloads the Docker image of <varname>mobilitydb</varname>. If the image has been downloaded before, this checks whether a more recent image has been published in the docker repository, and downloads it. It is better to call this command every time, to ensures that you have the latest most up-to-date version of this image.</para></listitem>

				<listitem><para><varname>docker volume create mobilitydb_data</varname> creates a volume container on the host, that we will use to persist the PostgreSQL database files outside of the MobilityDB container. You need to run this command only once, during the first use of the image</para>
				</listitem>

				<listitem><para><varname>docker run --name=mobilitydb</varname> tells Docker our new container will be named <varname>mobilitydb</varname>.</para></listitem>

				<listitem><para><varname>-d</varname> runs the container in the background (detached mode).</para></listitem>

				<listitem><para><varname>-p 25432:5432</varname> maps TCP port 5432 in the container to port 25432 on the Docker host (to prevent potential conflicts with any local database instance you may have). This is required because the PostgreSQL database server in the container listens for connections on port 5432 by default.</para>
				</listitem>

				<listitem><para><varname>-v mobilitydb_data:/var/lib/postgresql</varname> tells the container filesystem to mount the <varname>mobilitydb_data</varname> volume that we have just created to the path /var/lib/postgresql. This means that any database objects that the container saves or creates (by default in <varname>/var/lib/postgresql</varname>) will instead be persisted in the <varname>mobilitydb_data</varname> directory, which is stored in the host. This options ensures that your data will not be lost when the container is removed. </para>
				</listitem>

				<listitem><para><varname>mobilitydb/mobilitydb</varname> tells Docker to pull the docker image with that name from Docker Hub.</para>
				</listitem>
			</itemizedlist>
		</para>

		<para>
		Now we can launch any PostgreSQL administrative front-end to start using MobilityDB. Two traditional ones are the command-line tool <varname>psql</varname> and the graphical tool <varname>pgAdmin</varname>. We can launch <varname>psql</varname> as follows.
			<programlisting xml:space="preserve">
docker exec -t -i mobilitydb psql -h localhost -p 5432 -d mobilitydb -U docker
</programlisting>
			In the above command
			<itemizedlist>
				<listitem><para><varname>docker exec -t -i mobilitydb psql</varname> tells Docker to allocate a pseudo-TTY, to keep STDIN open, and to execute in the container <varname>mobilitydb</varname> the command <varname>psql</varname>.</para></listitem>

				<listitem><para><varname>-h localhost -p 5432 -d mobilitydb -U docker</varname> tells <varname>psql</varname>, respectively, the database server host, the server port, the database name, and the user name.</para></listitem>
			</itemizedlist>
			Note that you will be prompted to provide the password, which is also <varname>docker</varname>.
		</para>

		<para>
		In order to launch <varname>pgAdmin</varname>, there are two options to create a connection. The first option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port is 25432. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />.
		</para>

		<figure id="pgAdmin" float="start"><title>Configuration of a connection to the docker image in pgAdmin.</title>
			<mediaobject>
				<imageobject><imagedata scale='50' fileref='images/pgAdmin.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		The second option is to know the IP address used by docker container with the following command.
			<programlisting xml:space="preserve">
docker-machine ip
192.168.99.101
</programlisting>
			Notice that the address obtained in your computer may be different from the one above. Now we can launch <varname>pgAdmin</varname> and establish a new connection to the docker container. This is done as shown in <xref linkend="pgAdmin" />. The second option is to set the host to the localhost (127.0.0.1), and the port to the mapped one on the host, as per the <varname>docker run</varname> command. In this example the port would be 25432.
		</para>

		<para>
		Now you can use pgAdmin to query the mobilitydb database, as will be further explained in the following sections. Here are few more docker commands that you will eventually need:
		<programlisting xml:space="preserve">
docker stop "mobilitydb"
docker start "mobilitydb"
docker rm "mobilitydb"
</programlisting>
			The above commands
			<itemizedlist>
				<listitem>
					<para><varname>docker stop</varname> shuts down the docker container. You need to issue this command, for example, if you need to re-start the host.</para>
				</listitem>
				<listitem>
					<para><varname>docker start</varname> launches back the docker container. You need to issue this command, for example, after re-starting the host.</para>
				</listitem>

				<listitem>
					<para><varname>docker rm</varname> removes/deletes docker container. You need to issue this command, for example, if you need to <varname>docker pull</varname> a more recent MobilityDB image. If the databases are stored in a <varname>docker volume</varname> as explained above, it will still be available after downloading and running the new image.</para>
				</listitem>
			</itemizedlist>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data</title>

		<para>The ZIP file with the data for this tutorial contains a set of CSV files as follows:
			<itemizedlist>
				<listitem>
					<para><varname>vehicles.csv</varname> with fields <varname>VehicleId</varname>, <varname>Licence</varname>, <varname>Type</varname>, and <varname>Model</varname> contains the vehicle descriptions.</para>
				</listitem>

				<listitem>
					<para><varname>trips.csv</varname> with fields <varname>TripId</varname>, <varname>VehicleId</varname>, <varname>Lon</varname>, <varname>Lat</varname>, and <varname>Instant</varname> contains vehicles movements and pauses.</para>
				</listitem>

				<listitem>
					<para><varname>instants.csv</varname> with fields <varname>instantId</varname> and <varname>Instant</varname> contains timestamps used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>periods.csv</varname> with fields <varname>periodId</varname>, <varname>Begin</varname>, and <varname>End</varname> contains periods used for the queries.</para>
				</listitem>

				<listitem>
					<para><varname>points.csv</varname> with fields <varname>pointId</varname>, <varname>Lon</varname>, and <varname>Lat</varname> contains points used for queries.</para>
				</listitem>

				<listitem>
					<para><varname>regions.csv</varname> with fields <varname>regionId</varname>, <varname>PointNo</varname>, <varname>Lon</varname>, and <varname>Lat</varname> contains the polygons used for queries.</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>
		We decompress the file with the data into a directory. This can be done using the command.
			<programlisting xml:space="preserve">
unzip berlinmod_data.zip
</programlisting>
		We suppose in the following that the directory used is as follows <varname>/home/mobilitydb/data/</varname>.
		</para>

		<para>
		In the following, we can use the <varname>mobilitydb</varname> database provided in the container. This database has already installed the MobilityDB extension. Alternatively, you may use another database. In that case, you can install the MobilityDB extension in your database by using the following command.
			<programlisting xml:space="preserve">
CREATE EXTENSION MobilityDB CASCADE;
</programlisting>
		By using <varname>CASCADE</varname> we load the required PostGIS extension prior to loading MobilityDB.
		</para>

		<para>We create the tables to be loaded with the data in the CSV files as follows.
			<programlisting xml:space="preserve">
CREATE TABLE Vehicles (
  VehicleId integer PRIMARY KEY,
  Licence varchar(32),
  Type varchar(32),
  Model varchar(32) );
CREATE TABLE TripsInput (
  VehicleId integer REFERENCES Vehicles,
  TripId integer,
  Lon float,
  Lat float,
  T timestamptz,
  PRIMARY KEY (TripId, T) );
CREATE TABLE Instants (
  InstantId integer PRIMARY KEY,
  Instant timestamptz );
CREATE TABLE Periods (
  PeriodId integer PRIMARY KEY,
  Tstart TimestampTz,
  Tend TimestampTz,
  Period period );
CREATE TABLE Points (
  PointId integer PRIMARY KEY,
  Lon double precision,
  Lat double precision,
  Geom Geometry(Point) );
CREATE TABLE RegionsInput (
  RegionId integer,
  PointNo integer,
  Lon double precision,
  Lat double precision,
  PRIMARY KEY (RegionId, PointNo) );
CREATE TABLE Regions (
  RegionId integer PRIMARY KEY,
  Geom Geometry(Polygon) );
CREATE TABLE Trips (
  TripId integer PRIMARY KEY,
  VehicleId integer NOT NULL,
  Trip tgeompoint,
  FOREIGN KEY (VehicleId) REFERENCES Vehicles (VehicleId) );
</programlisting>
		We created one table for each CSV file. In addition, we created a table <varname>Regions</varname> in order to assemble all segments composing a region into a single geometry and a table <varname>Trips</varname> in order to assemble all points composing a trip into a single temporal point.
		</para>

		<para>
		We can load the CSV files into the corresponding tables as follows.
			<programlisting xml:space="preserve">
COPY Vehicles(VehicleId, Licence, Type, Model) FROM '/home/mobilitydb/data/vehicles.csv'
  DELIMITER ',' CSV HEADER;
COPY TripsInput(TripId, VehicleId, Lon, Lat, T) FROM '/home/mobilitydb/data/trips.csv'
  DELIMITER ',' CSV HEADER;
COPY Instants(InstantId, Instant) FROM '/home/mobilitydb/data/instants.csv'
  DELIMITER ',' CSV HEADER;
COPY Periods(PeriodId, Tstart, Tend) FROM '/home/mobilitydb/data/periods.csv'
  DELIMITER ',' CSV HEADER;
UPDATE Periods
SET Period = period(Tstart, Tend);
COPY Points(PointId, Lon, Lat) FROM '/home/mobilitydb/data/points.csv'
  DELIMITER ',' CSV HEADER;
UPDATE Points
SET Geom = ST_Transform(ST_SetSRID(ST_MakePoint(Lon, Lat), 4326), 3812);
COPY RegionsInput(RegionId, PointNo, Lon, Lat) FROM
  '/home/mobilitydb/data/regions.csv' DELIMITER ',' CSV HEADER;
</programlisting>
		</para>

		<para>The following query is used to load table <varname>Regions</varname> from the data in table <varname>RegionsInput</varname>.
			<programlisting xml:space="preserve">
INSERT INTO Regions (RegionId, Geom)
SELECT RegionId, ST_MakePolygon(ST_MakeLine(array_agg(ST_Transform(ST_SetSRID(
  ST_MakePoint(Lon, Lat), 4326), 3812) ORDER BY PointNo))) AS Geom
FROM RegionsInput
GROUP BY RegionId;
</programlisting>
		</para>

		<para>The following query is used to load table <varname>Trips</varname> from the data in table <varname>TripsInput</varname>.
			<programlisting xml:space="preserve">
INSERT INTO Trips(TripId, VehicleId, trip)
SELECT TripId, VehicleId, tgeompoint_seq(array_agg(tgeompoint_inst(
  ST_Transform(ST_SetSRID(ST_MakePoint(Lon, Lat), 4326), 2812), T) ORDER BY T))
FROM TripsInput
GROUP BY TripId, VehicleId;
</programlisting>
		There are a lot of nested functions, so reading from the innermost:
			<itemizedlist>
				<listitem>
					<para>Function <varname>ST_MakePoint</varname> construct a point from the <varname>Lon</varname> and <varname>Lat</varname> values.</para>
				</listitem>

				<listitem>
					<para>Function <varname>ST_SetSRID</varname> sets the SRID of the point to 4326, that is, to the standard WGS 84 GPS coordinates.</para>
				</listitem>

				<listitem>
					<para>Function <varname>ST_Transform</varname> transforms the spherical GPS coordinates to plannar coordinates fitted for Germany.</para>
				</listitem>

				<listitem>
					<para>Function <varname>tgeompoint_inst</varname> gets the point and the time values to create a temporal point of instant duration.</para>
				</listitem>

				<listitem>
					<para>Function <varname>array_agg</varname> collects in an array all temporal points of a given car and a given trip (as specified by the <varname>GROUP BY</varname> clause) and sort them by time (as specified by the <varname>ORDER BY</varname> clause)</para>
				</listitem>

				<listitem>
					<para>Function <varname>tgeompoint_seq</varname> gets the array of temporal points and construct a temporal point of sequence duration.</para>
				</listitem>

			</itemizedlist>
		</para>

		<para>Finally, we create indexes on traditional, spatial, temporal or spatiotemporal attributes as well as views to select a subset of the rows from the corresponding tables. This can be done as follows.
			<programlisting xml:space="preserve">
CREATE INDEX Points_Geom_Idx ON Points USING gist(Geom);
CREATE INDEX Regions_Geom_Idx ON Regions USING gist(Geom);
CREATE INDEX Trips_Trip_idx ON Trips USING gist(Trip);

CREATE VIEW Instants1 AS SELECT * FROM Instants LIMIT 10;
CREATE VIEW Periods1 AS SELECT * FROM Periods LIMIT 10;
CREATE VIEW Points1 AS SELECT * FROM Points LIMIT 10;
CREATE VIEW Regions1 AS SELECT * FROM Regions LIMIT 10;
CREATE VIEW Trips1 AS SELECT * FROM Trips LIMIT 100;
</programlisting>
		</para>
	</sect1>

	<sect1>
		<title>Loading the Data in Partitioned Tables</title>
		<para>
		PostgreSQL provides partitioning mechanisms so that large tables can be split in smaller physical tables. This may result in increased performance when querying and manipulating large tables. We will split the <varname>Trips</varname> table given in the previous section using list partitioning, where each partitition will contain all the trips that start at a particular date. For doing this, we use the procedure given next for automatically creating the partitions according to a date range.
		</para>
		<programlisting xml:space="preserve">
CREATE OR REPLACE FUNCTION create_partitions_by_date(TableName TEXT, StartDate DATE,
  EndDate DATE)
RETURNS void AS $$
DECLARE
  d DATE;
  PartitionName TEXT;
BEGIN
  IF NOT EXISTS (
    SELECT 1
    FROM information_schema.tables
    WHERE table_name = lower(TableName))
  THEN
    RAISE EXCEPTION 'Table % does not exist', TableName;
  END IF;
  IF StartDate &gt;= EndDate THEN
    RAISE EXCEPTION 'The start date % must be before the end date %', StartDate, EndDate;
  END IF;
  d = StartDate;
  WHILE d &lt;= EndDate
  LOOP
    PartitionName = TableName || '_' || to_char(d, 'YYYY_MM_DD');
    IF NOT EXISTS (
      SELECT 1
       FROM information_schema.tables
       WHERE  table_name = lower(PartitionName))
    THEN
      EXECUTE format('CREATE TABLE %s PARTITION OF %s FOR VALUES IN (''%s'');',
        PartitionName, TableName, to_char(d, 'YYYY-MM-DD'));
      RAISE NOTICE 'Partition % has been created', PartitionName;
    END IF;
    d = d + '1 day'::interval;
  END LOOP;
  RETURN;
END
$$ LANGUAGE plpgsql;
</programlisting>

		<para>In order to partition table <varname>Trips</varname> by date we need to add an addition column <varname>TripDate</varname> to table <varname>TripsInput</varname>.
			<programlisting xml:space="preserve">
ALTER TABLE TripsInput ADD COLUMN TripDate DATE;
UPDATE TripsInput T1
SET TripDate = T2.TripDate
FROM (
  SELECT DISTINCT TripId,
    date_trunc('day', MIN(T) OVER (PARTITION BY TripId)) AS TripDate
  FROM TripsInput) T2
WHERE T1.TripId = T2.TripId;
</programlisting>
		Notice that the <varname>UPDATE</varname> statement above takes into account the fact that a trip may finish at a day later than the starting day.
		</para>

		<para>
		The following statements create table <varname>Trips</varname> partitioned by date and the associated partitions.
			<programlisting xml:space="preserve">
CREATE TABLE Trips (
  VehicleId integer NOT NULL,
  TripId integer NOT NULL,
  TripDate date,
  Trip tgeompoint,
  Traj geometry,
  PRIMARY KEY (VehicleId, TripId, TripDate),
  FOREIGN KEY (VehicleId) REFERENCES Vehicles (VehicleId)
) PARTITION BY LIST(TripDate);

SELECT create_partitions_by_date('Trips', (SELECT MIN(TripDate) FROM TripsInput),
(SELECT MAX(TripDate) FROM TripsInput));
</programlisting>
		</para>

		<para>
		To see the partitions that have been created automatically we can use the following statement.
			<programlisting xml:space="preserve">
SELECT I.inhrelid::regclass AS child
FROM pg_inherits I
WHERE i.inhparent = 'trips'::regclass;
</programlisting>
		In our case this would result in the following output.
			<programlisting xml:space="preserve">
"trips_2007_05_27"
"trips_2007_05_28"
"trips_2007_05_29"
"trips_2007_05_30"
</programlisting>
		</para>

		<para>We modify the query that loads table <varname>Trips</varname> from the data in table <varname>TripsInput</varname> as follows.
			<programlisting xml:space="preserve">
INSERT INTO Trips
SELECT VehicleId, TripId, TripDate, tgeompointseq(array_agg(tgeompointinst(
  ST_Transform(ST_SetSRID(ST_MakePoint(Lon,Lat), 4326), 5676), T) ORDER BY T))
FROM TripsInput
GROUP BY VehicleId, TripId, TripDate;
</programlisting>
		Then, we can define the indexes and the views on the table <varname>Trips</varname> as shown in the previous section.
		</para>

		<para>
		An important advantange of the partitioning mechanism in PostgreSQL is that the constraints and the indexes defined on the <varname>Trips</varname> table are propagated to the partitions as shown next.
		</para>
		<programlisting xml:space="preserve">
INSERT INTO Trips VALUES (1, 10, '2007-05-30', NULL);

ERROR:  duplicate key value violates unique constraint "trips_2007_05_30_pkey"
DETAIL:  Key (VehicleId, TripId, tripdate)=(1, 10, 2007-05-30) already exists.

EXPLAIN SELECT COUNT(*) from Trips where Trip &amp;&amp; period '[2007-05-28, 2007-05-29]';

"Aggregate  (cost=59.95..59.96 rows=1 width=8)"
"  ->  Append  (cost=0.14..59.93 rows=8 width=0)"
"        ->  Index Scan using trips_2007_05_27_trip_idx on trips_2007_05_27  (cost=0.14..8.16 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_28_trip_idx on trips_2007_05_28  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
"        ->  Index Scan using trips_2007_05_29_trip_idx on trips_2007_05_29  (cost=0.27..8.29 rows=1 width=0)"
"              Index Cond: (trip &amp;&amp; 'STBOX T((,,2007-05-28 00:00:00+00),(,,2007-05-29 00:00:00+00))'::stbox)"
[...]
</programlisting>

	</sect1>

	<sect1>
		<title>Exploring the Data</title>
		<para>In order to visualize the data with traditional tools such as <ulink url="https://qgis.org/">QGIS</ulink> we add to table <varname>Trip</varname> a column <varname>Traj</varname> of type <varname>geometry</varname> containing the trajectory of the trips.
			<programlisting xml:space="preserve">
ALTER TABLE Trips ADD COLUMN traj geometry;
UPDATE Trips
SET Traj = trajectory(Trip);
</programlisting>
		The visualization of the trajectories in QGIS is given in <xref linkend="berlinmod_trips" />. In the figure red lines correspond to the trajectories of moving vehicles, while yellow points correspond to the position of stationary vehicles. In order to know the total number of trips as well as the number of moving and stationary trips we can issue the following queries.
			<programlisting xml:space="preserve">
SELECT count(*) FROM Trips;
-- 1797
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'POINT';
-- 969
SELECT count(*) FROM Trips WHERE GeometryType(Traj) = 'LINESTRING';
-- 828
</programlisting>
		We can also determine the spatiotemporal extent of the data using the following query.
			<programlisting xml:space="preserve">
SELECT extent(Trip) from Trips
-- "STBOX T((2983189.5, 5831006.5,2007-05-27 00:00:00+02),
(3021179.8, 5860883,2007-05-31 00:00:00+02))"
</programlisting>
		</para>

		<figure id="berlinmod_trips" float="start"><title>Visualization of the trajectories of the trips in QGIS.</title>
			<mediaobject>
				<imageobject><imagedata scalefit="1" fileref='images/berlinmod_trips.png' /></imageobject>
			</mediaobject>
		</figure>

		<para>
		We continue investigating the data set by computing the maximum number of concurrent trips over the whole period
			<programlisting xml:space="preserve">
SELECT maxValue(tcount(Trip)) FROM Trips;
-- 141
</programlisting>
		the average sampling rate
			<programlisting xml:space="preserve">
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips;
-- "03:43:01.695539"
</programlisting>
			and the total travelled distance in kilometers of all trips:
			<programlisting xml:space="preserve">
SELECT SUM(length(Trip)) / 1e3 as TotalLengthKm FROM Trips;
-- 10074.8123345527
</programlisting>
		</para>

		<para>
		Now we want to know the average duration of a trip.
			<programlisting xml:space="preserve">
SELECT AVG(timespan(Trip)) FROM Trips;
--"07:31:57.195325"
</programlisting>
		This average duration is too long. To investigate more we use the following query
			<programlisting xml:space="preserve">
SELECT length(Trip) / 1e3, timespan(Trip) FROM Trips ORDER BY duration;
</programlisting>
		The query shows very many trips with zero length and a duration of more than one day. That would imply that there are stationary trips, representing parking overnight and even over the weekend. The previous query can hence be refined as follows:
			<programlisting xml:space="preserve">
SELECT AVG(timespan(Trip)/numInstants(Trip)) FROM Trips WHERE length(Trip) > 0;
-- "00:00:01.861784"
</programlisting>
		</para>

		<para>
		The following query produces a histogram of trip length.
			<programlisting xml:space="preserve">
WITH buckets (bucketNo, bucketRange) AS (
  SELECT 1, floatrange '[0, 0]' UNION
  SELECT 2, floatrange '(0, 100)' UNION
  SELECT 3, floatrange '[100, 1000)' UNION
  SELECT 4, floatrange '[1000, 5000)' UNION
  SELECT 5, floatrange '[5000, 10000)' UNION
  SELECT 6, floatrange '[10000, 50000)' UNION
  SELECT 7, floatrange '[50000, 100000)' ),
histogram AS (
  SELECT bucketNo, bucketRange, count(TripId) as freq
  FROM buckets left outer join trips on length(trip) &lt;@ bucketRange
  GROUP BY bucketNo, bucketRange
  ORDER BY bucketNo, bucketRange )
SELECT bucketNo, bucketRange, freq,
  repeat('&#9632;', ( freq::float / max(freq) OVER () * 30 )::int ) AS bar
FROM histogram;
</programlisting>
			The result of the above query is given in <xref linkend="histogram_length" />.
		</para>

		<figure id="histogram_length" float="start"><title>Result of the query building an histogram of trip lengths.</title>
			<mediaobject>
				<imageobject><imagedata scale='80' fileref='images/histogram_length.png' /></imageobject>
			</mediaobject>
		</figure>

	</sect1>

	<sect1>
		<title>Querying the Data</title>
		<para>We discuss next four categories of queries: range queries, distance queries, temporal aggregate queries, and nearest-neighbor queries.</para>

		<sect2>
			<title>Range Queries</title>
			<para>The queries in this category restrict Trips with respect to a spatial, temporal, or spatio-temporal point or range. In the examples, the spatial points and ranges are given, respectively, in tables <varname>Points</varname> and <varname>Regions</varname>, while temporal points and ranges are given, respectively, in tables <varname>Instants</varname> and <varname>Periods</varname>.</para>

			<orderedlist>
				<listitem id="qa_range_spatial">
					<para>List the vehicles that have passed at a region from <varname>Regions</varname>.</para>
					<programlisting xml:space="preserve">
SELECT DISTINCT R.RegionId, T.VehicleId
FROM Trips T, Regions R
WHERE ST_Intersects(trajectory(T.Trip), R.Geom)
ORDER BY R.RegionId, T.VehicleId;
</programlisting>
					<para>This is a spatial range query. The query verifies that the trajectory of the car intersects the region. PostGIS performs an implicit bounding box comparison <varname>trajectory(T.Trip) &amp;&amp; R.Geom</varname> using the spatial index on table <varname>Regions</varname> when executing the predicate <varname>ST_Intersects</varname>.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal">
					<para>List the vehicles that were within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting xml:space="preserve">
SELECT R.RegionId, P.PeriodId, T.VehicleId
FROM Trips T, Regions R, Periods P
WHERE T.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
  _intersects(atPeriod(T.Trip, P.Period), R.Geom)
ORDER BY R.RegionId, P.PeriodId, T.VehicleId;
</programlisting>
					<para>This is a spatio-temporal range query. The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on table <varname>Trips</varname>. After that, the query verifies that the location of the car during the period intersects the region. Notice that the predicate <varname>_intersects</varname> is used instead of <varname>intersects</varname> to avoid an implicit index test with the bounding box comparison <varname>atPeriod(Trip, P.Period) &amp;&amp; R.Geom</varname> is performed using the spatio-temporal index.</para>
				</listitem>

				<listitem id="qa_range_spatiotemporal_join">
					<para>List the pairs of vehicles that were both located within a region from <varname>Regions</varname> during a period from <varname>Periods</varname>.</para>
					<programlisting xml:space="preserve">
SELECT DISTINCT T1.VehicleId AS VehicleId1, T2.VehicleId AS VehicleId2, R.RegionId, P.PeriodId
FROM Trips T1, Trips T2, Regions R, Periods P
WHERE T1.VehicleId &lt; T2.VehicleId AND T1.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
  T2.Trip &amp;&amp; stbox(R.Geom, P.Period) AND
  _intersects(atPeriod(T1.Trip, P.Period), R.Geom) AND
  _intersects(atPeriod(T2.Trip, P.Period), R.Geom)
ORDER BY T1.VehicleId, T2.VehicleId, R.RegionId, P.PeriodId;
</programlisting>
					<para>This is a spatio-temporal range join query. The query selects two trips of different vehicles and performs bounding box comparisons of each trip with a region and a period using the spatio-temporal index of the <varname>Trips</varname> table. The query then verifies that both vehicles were located within the region during the period.</para>
				</listitem>

				<listitem id="qa_range_entering">
					<para>List the first time at which a car visited a point in <varname>Points</varname>.</para>
					<programlisting xml:space="preserve">
SELECT T.VehicleId, P.PointId, MIN(startTimestamp(atValue(T.Trip,P.Geom))) AS Instant
FROM Trips T, Points P
WHERE ST_Contains(trajectory(T.Trip), P.Geom)
GROUP BY T.VehicleId, P.PointId;
</programlisting>
					<para>The query selects a trip and a point and verifies that the car passed by the point by testing that the trajectory of the trip contains the point. Notice that PostGIS will perform the bounding box containment <varname>trajectory(T.Trip) ~ P.Geom</varname> using the spatial index on table <varname>Points</varname> before executing <varname>ST_Contains</varname>. Then, the query projects the trip to the point with the <varname>atValue</varname> function, get the first timestamp of the projected trip with the <varname>startTimestamp</varname> function, and applies the traditional <varname>MIN</varname> aggregate function for all trips of the car and the point.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Temporal Aggregate Queries</title>
			<para>There are three common types of temporal aggregate queries.
				<itemizedlist>
					<listitem>
						<para>Instant temporal aggregate queries in which, from a conceptual perspective, the traditional aggregate function is applied at each instant.</para>
					</listitem>

					<listitem>
						<para>Window temporal aggregate queries (also known as cumulative queries), which, given a time interval w, compute the value of the aggregate at a time instant t from the values during the time period [t-w, t].</para>
					</listitem>

					<listitem>
						<para>Span temporal aggregate queries, which, first, split the time line into predefined intervals independently of the target data, and then, for each of these intervals, aggregate the data that overlap the interval.</para>
					</listitem>
				</itemizedlist>
			</para>

			<orderedlist continuation="continues">
				<listitem id="qa_aggregate_instant">
					<para>Compute how many vehicles were active at each period in <varname>Periods</varname>.</para>
					<programlisting xml:space="preserve">
SELECT P.PeriodId, COUNT(*), TCOUNT(atPeriod(T.Trip, P.Period))
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY P.PeriodId
ORDER BY P.PeriodId;
</programlisting>
					<para>This an instant temporal aggregate query. For each period, the query projects the trips to the given period and applies the temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index on table <varname>Trips</varname>.</para>
				</listitem>

				<listitem id="qa_aggregate_window">
					<para>For each region in <varname>Regions</varname>, give the window temporal count of trips with a 10-minute interval.</para>
					<programlisting xml:space="preserve">
SELECT R.RegionId, WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min')
FROM Trips T, Regions R
WHERE T.Trip &amp;&amp; R.Geom
GROUP BY R.RegionId
HAVING WCOUNT(atGeometry(T.Trip, R.Geom), interval '10 min') IS NOT NULL
ORDER BY R.RegionId;
</programlisting>
					<para>This is a window temporal aggregate query. Suppose that we are computing pollution levels by region. Since the effect of a car passing at a location lasts some time interval, this is a typical case for window aggregates. For each region, the query computes the spatial projection of the trips to the given region and apply the window temporal count to the projected trips. The condition in the <varname>WHERE</varname> clause is used for filtering the trips with the spatio-temporal index. The condition in the <varname>HAVING</varname> clause is used for removing regions that do not intersect with any trip.</para>
				</listitem>

				<listitem id="qa_aggregate_span">
					<para>Count the number of trips that were active during each hour in May 29, 2007.</para>
					<programlisting xml:space="preserve">
WITH TimeSplit(Period) AS (
  SELECT period(H, H + interval '1 hour')
  FROM generate_series(timestamptz '2007-05-29 00:00:00',
    timestamptz '2007-05-29 23:00:00', interval '1 hour') AS H )
SELECT Period, COUNT(*)
FROM TimeSplit S, Trips T
WHERE S.Period &amp;&amp; T.Trip AND atPeriod(Trip, Period) IS NOT NULL
GROUP BY S.Period
ORDER BY S.Period;
</programlisting>
					<para>This is a span temporal aggregate query. The query defines the intervals to consider in the <varname>TimeSplit</varname> temporary table. For each of these intervals, the main query applies the traditional count function for counting the trips that overlap the interval.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Distance Queries</title>
			<para>The queries in this category deal with either the distance travelled by a single object or the distance between two objects. The complexity of the latter queries depend, on the one hand, on whether the reference objects are static or moving, and on the other, on whether the operation required is either the minimum distance ever or the temporal distance computed at each instant.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_distance_overall">
					<para>List the overall traveled distances of the vehicles during the periods from <varname>Periods</varname>.</para>
					<programlisting xml:space="preserve">
SELECT T.VehicleId, P.PeriodId, P.Period,
  SUM(length(atPeriod(T.Trip, P.Period))) AS Distance
FROM Trips T, Periods P
WHERE T.Trip &amp;&amp; P.Period
GROUP BY T.VehicleId, P.PeriodId, P.Period
ORDER BY T.VehicleId, P.PeriodId;
</programlisting>
					<para>The query performs a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table. It then projects the trip to the period, computes the length of the projected trip, and sum the lengths of all the trips of the same car during the period.</para>
				</listitem>

				<listitem id="qa_distance_static">
					<para>List the minimum distance ever between each car and each point from <varname>Points</varname>.</para>
					<programlisting xml:space="preserve">
SELECT T.VehicleId, P.PointId, MIN(trajectory(T.Trip) &lt;-&gt; P.Geom) AS MinDistance
FROM Trips T, Points P
GROUP BY T.VehicleId, P.PointId
ORDER BY T.VehicleId, P.PointId;
</programlisting>
					<para>The query projects the trip to the spatial dimension with the <varname>trajectory</varname> function and computes the traditional distance between the trajectory of the trip and the point. The traditional minimum function is then applied for computing the minimum distance between all trips of the car and the point.</para>
				</listitem>

				<listitem id="qa_distance_moving">
					<para>List the minimum temporal distance between each pair of vehicles.</para>
					<programlisting xml:space="preserve">
SELECT T1.VehicleId AS Car1Id, T2.VehicleId AS Car2Id,
  MIN(T1.Trip &lt;-&gt; T2.Trip) AS MinDistance
FROM Trips T1, Trips T2
WHERE T1.VehicleId &lt; T2.VehicleId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
GROUP BY T1.VehicleId, T2.VehicleId
ORDER BY T1.VehicleId, T2.VehicleId;
</programlisting>
					<para>The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different vehicles that were both traveling during a common period of time, computes the temporal distance between the trips, and then computes the temporal minimum distance between all trips of the two vehicles. The query uses the spatio-temporal index to filter the pairs of trips that were both traveling during a common period of time.</para>
				</listitem>

				<listitem id="qa_nearest_approach">
					<para>List the nearest approach time, distance, and shortest line between each pair of trips.</para>
					<programlisting xml:space="preserve">
SELECT T1.VehicleId AS Car1Id, T1.TripId AS Trip1Id, T2.VehicleId AS Car2Id,
  T2.TripId AS Trip2Id, period(NearestApproachInstant(T1.Trip, T2.Trip)) AS Time,
  NearestApproachDistance(T1.Trip, T2.Trip) AS Distance,
  ShortestLine(T1.Trip, T2.Trip) AS Line
FROM Trips1 T1, Trips1 T
WHERE T1.VehicleId &lt; T2.VehicleId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
ORDER BY T1.VehicleId, T1.TripId, T2.VehicleId, T2.TripId;
</programlisting>
					<para>This query shows similar functionality as that provided by the PostGIS functions <varname>ST_ClosestPointOfApproach</varname> and <varname>ST_DistanceCPA</varname>. The query selects two trips <varname>T1</varname> and <varname>T2</varname> from different vehicles that were both traveling during a common period of time and computes the required results.</para>
				</listitem>

				<listitem id="qa_distance_tdwithin">
					<para>List when and where a pairs of vehicles have been at 10 m or less from each other.</para>
					<programlisting xml:space="preserve">
SELECT T1.VehicleId AS VehicleId1, T2.VehicleId AS VehicleId2, atPeriodSet(T1.Trip,
  period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE))) AS Position
FROM Trips T1, Trips T
WHERE T1.VehicleId &lt; T2.VehicleId AND T1.Trip &amp;&amp; expandSpatial(T2.Trip, 10) AND
  atPeriodSet(T1.Trip, period(atValue(tdwithin(T1.Trip, T2.Trip, 10.0), TRUE)))
  IS NOT NULL
ORDER BY T1.VehicleId, T2.VehicleId, Position;
</programlisting>
					<para>The query performs for each pair of trips <varname>T1</varname> and <varname>T2</varname> of different cars a bounding box comparison with the <varname>&amp;&amp;</varname> operator using the spatio-temporal index on the <varname>Trips</varname> table, where the bounding box of <varname>T2</varname> is expanded by 10 m. Then, the <varname>period</varname> expression computes the periods during which the cars were within 10 m. from each other and the <varname>atPeriodSet</varname> function projects the trips to those periods. Notice that the expression <varname>tdwithin(T1.Trip, T2.Trip, 10.0)</varname> is conceptually equivalent to <varname>dwithin(T1.Trip, T2.Trip) #&lt;= 10.0</varname>. However, in this case the spatio-temporal index cannot be used for filtering values.</para>
				</listitem>
			</orderedlist>
		</sect2>

		<sect2>
			<title>Nearest-Neighbor Queries</title>
			<para>There are three common types of nearest-neighbor queries in spatial databases.
				<itemizedlist>
					<listitem>
						<para>k-nearest-neighbor (kNN) queries find the k nearest points to a given point.</para>
					</listitem>

					<listitem>
						<para>Reverse k-nearest-neighbor (RkNN) queries find the points that have a given point among their k nearest-neighbors.</para>
					</listitem>

					<listitem>
						<para>Given two sets of points P and Q, aggregate nearest-neighbor (ANN) queries find the points from P that have minimum aggregated distance to all points from Q.</para>
					</listitem>
				</itemizedlist>
			</para>

			<para>The above types of queries are generalized to temporal points. However, the complexity of these queries depend on whether the reference object and the candidate objects are static or moving. In the examples that follow we only consider the nontemporal version of the nearest-neighbor queries, that is, the one in which the calculation is performed on the projection of temporal points on the spatial dimension. The temporal version of the nearest-neighbor queries remains to be done.</para>

			<orderedlist continuation="continues">
				<listitem id="qa_knn_static">
					<para>For each trip from <varname>Trips</varname>, list the three points from <varname>Points</varname> that have been closest to that car.</para>
					<programlisting xml:space="preserve">
WITH TripsTraj AS (
  SELECT *, trajectory(Trip) AS Trajectory FROM Trips )
SELECT T.VehicleId, P1.PointId, P1.Distance
FROM TripsTraj T CROSS JOIN LATERAL (
  SELECT P.PointId, T.Trajectory &lt;-&gt; P.Geom AS Distance
  FROM Points P
  ORDER BY Distance LIMIT 3 ) AS P1
ORDER BY T.TripId, T.VehicleId, P1.Distance;
</programlisting>
					<para>This is a nearest-neighbor query with moving reference objects and static candidate objects. The query above uses PostgreSQL's lateral join, which intuitively iterates over each row in a result set and evaluates a subquery using that row as a parameter. The query starts by computing the trajectory of the trips in the temporary table <varname>TripsTraj</varname>. Then, given a trip <varname>T</varname> in the outer query, the subquery computes the traditional distance between the trajectory of <varname>T</varname> and each point <varname>P</varname>. The <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest points. PostGIS will use the spatial index on the <varname>Points</varname> table for selecting the three closest points.</para>
				</listitem>

				<listitem id="qa_knn_moving">
					<para>For each trip from <varname>Trips</varname>, list the three cars that are closest to that car</para>
					<programlisting xml:space="preserve">
SELECT T1.VehicleId AS VehicleId1, C2.VehicleId AS VehicleId2, C2.Distance
FROM Trips T1 CROSS JOIN LATERAL (
  SELECT T2.VehicleId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
  FROM Trips T2
  WHERE T1.VehicleId &lt; T2.VehicleId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
  ORDER BY Distance LIMIT 3 ) AS C2
ORDER BY T1.VehicleId, C2.VehicleId;
</programlisting>
					<para>This is a nearest-neighbor query where both the reference and the candidate objects are moving. Therefore, it is not possible to proceed as in the previous query to first project the moving points to the spatial dimension and then compute the traditional distance. Given a trip <varname>T1</varname> in the outer query, the subquery computes the temporal distance between <varname>T1</varname> and a trip <varname>T2</varname> of another car different from the car from <varname>T1</varname> and then computes the minimum value in the temporal distance. Finally, the <varname>ORDER BY</varname> and <varname>LIMIT</varname> clauses in the inner query select the three closest cars.</para>
				</listitem>

				<listitem id="qa_rknn_static">
					<para>For each trip from <varname>Trips</varname>, list the points from <varname>Points</varname> that have that car among their three nearest neighbors.</para>
					<programlisting xml:space="preserve">
WITH TripsTraj AS (
  SELECT *, trajectory(Trip) AS Trajectory FROM Trips ),
PointTrips AS (
  SELECT P.PointId, T2.VehicleId, T2.TripId, T2.Distance
  FROM Points P CROSS JOIN LATERAL (
    SELECT T1.VehicleId, T1.TripId, P.Geom &lt;-&gt; T1.Trajectory AS Distance
    FROM TripsTraj T
    ORDER BY Distance LIMIT 3 ) AS T2 )
SELECT T.VehicleId, T.TripId, P.PointId, PT.Distance
FROM Trips T CROSS JOIN Points P JOIN PointTrips PT
  ON T.VehicleId = PT.VehicleId AND T.TripId = PT.TripId AND P.PointId = PT.PointId
ORDER BY T.VehicleId, T.TripId, P.PointId;
</programlisting>
					<para>This is a reverse nearest-neighbor query with moving reference objects and static candidate objects. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>PointTrips</varname> as it is done in Query 13. Then, in the main query it verifies for each trip <varname>T</varname> and point <varname>P</varname> that both belong to the <varname>PointTrips</varname> table.</para>
				</listitem>

				<listitem id="qa_rknn_moving">
					<para>For each trip from <varname>Trips</varname>, list the cars having the car of the trip among the three nearest neighbors.</para>
					<programlisting xml:space="preserve">
WITH TripDistances AS (
  SELECT T1.VehicleId AS VehicleId1, T1.TripId AS TripId1, T3.VehicleId AS VehicleId2,
    T3.TripId AS TripId2, T3.Distance
  FROM Trips T1 CROSS JOIN LATERAL (
    SELECT T2.VehicleId, T2.TripId, minValue(T1.Trip &lt;-&gt; T2.Trip) AS Distance
    FROM Trips T
    WHERE T1.VehicleId &lt; T2.VehicleId AND period(T1.Trip) &amp;&amp; period(T2.Trip)
    ORDER BY Distance LIMIT 3 ) AS T3 )
SELECT T1.VehicleId, T1.TripId, T2.VehicleId, T2.TripId, TD.Distance
FROM Trips T1 JOIN Trips T2 ON T1.VehicleId &lt; T2.VehicleId
  JOIN TripDistances TD ON T1.VehicleId = TD.VehicleId1 AND T1.TripId = TD.TripId1 AND
  T2.VehicleId = TD.VehicleId2 AND T2.TripId = TD.TripId
ORDER BY T1.VehicleId, T1.TripId, T2.VehicleId, T2.TripId;
</programlisting>
					<para>This is a reverse nearest-neighbor query where both the reference and the candidate objects are moving. The query starts by computing the corresponding nearest-neighbor query in the temporary table <varname>TripDistances</varname> as it is done in Query 14. Then, in the main query it verifies for each pair of trips <varname>T1</varname> and <varname>T2</varname> that both belong to the <varname>TripDistances</varname> table.</para>
				</listitem>

				<listitem id="qa_ann">
					<para>For each group of ten disjoint vehicles, list the point(s) from <varname>Points</varname>, having the minimum aggregated distance from the given group of ten vehicles during the given period.</para>
					<programlisting xml:space="preserve">
WITH Groups AS (
  SELECT ((ROW_NUMBER() OVER (ORDER BY V.VehicleId))-1)/10 + 1 AS GroupId, V.VehicleId
  FROM Vehicles V ),
SumDistances AS (
  SELECT G.GroupId, P.PointId,
    SUM(ST_Distance(trajectory(T.Trip), P.Geom)) AS SumDist
  FROM Groups G, Points P, Trips T
  WHERE T.VehicleId = G.VehicleId
  GROUP BY G.GroupId, P.PointId )
SELECT S1.GroupId, S1.PointId, S1.SumDist
FROM SumDistances S
WHERE S1.SumDist &lt;= ALL (
  SELECT SumDist
  FROM SumDistances S
  WHERE S1.GroupId = S2.GroupId )
ORDER BY S1.GroupId, S1.PointId;
</programlisting>
					<para>This is an aggregate nearest-neighbor query. The temporary table <varname>Groups</varname> splits the vehicles in groups where the <varname>GroupId</varname> column takes the values from 1 to total number of groups. The temporary table <varname>SumDistances</varname> computes for each group <varname>G</varname> and point <varname>P</varname> the sum of the distances between a trip of a car in the group and the point. The main query then selects for each group in table <varname>SumDistances</varname> the points(s) that have the minimum aggregated distance.</para>
				</listitem>
			</orderedlist>
		</sect2>
	</sect1>
</chapter>
